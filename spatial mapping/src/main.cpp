///////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2017, STEREOLABS.
//
// All rights reserved.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
///////////////////////////////////////////////////////////////////////////


/******************************************************************************************
 ** This sample demonstrates a simple way to use the Spatial Mapping API with the ZED    **
 ** It show the left image and the current mesh generated on a wireframe mode            **
 ** on top of the image                                                                  **
 ** Spatial Mapping can be started and stopped with the Space Bar key                    **
 ******************************************************************************************/
 
 
// Standard includes
#include <stdio.h>    // standard (I/O library)
#include <stdlib.h>   // standard library (set of standard C functions
#include <math.h>     // Math library (Higher math functions )
 
// OpenGL includes
#include <GL/glew.h>
#include "GL/freeglut.h"

// ZED includes
#include <sl/Camera.hpp>

// Sample includes
#include "GLObject.hpp" // Utils to use GLSL Shader and mesh
#include "utils.hpp"
#include "cuda_gl_interop.h"


/// ZED object (camera, mesh, pose)
sl::Camera zed_; //handle to ZED Camera
sl::Mat left_image; //sl::Mat to handle a image on gpu
sl::Pose pose_; //sl::Pose to handle the position of the ZED in world space
sl::Mesh mesh_; //sl::Mesh to handle the mesh generated by the spatial mapping 
sl::SpatialMappingParameters spatial_mapping_params;
sl::MeshFilterParameters filter_params;
sl::TRACKING_STATE tracking_state;

// For CUDA-OpenGL interoperability
cudaGraphicsResource* pcuImageRes; //cuda GL resource

// Opengl mesh container
MeshObject* mesh_object = NULL;
sl::float3 mesh_color; //defines the color of the mesh

// Opengl object
Shader* shader_mesh = NULL; //GLSL Shader for mesh
Shader* shader_image = NULL; //GLSL Shader for image
GLuint zed_window; //window ID
GLuint imageTex; //OpenGL texture mapped with a cuda array (opengl gpu interop)
GLuint shMVPMatrixLoc_; //Shader variable loc
GLuint shColorLoc_; //Shader variable loc
GLuint texID; //Shader variable loc (sampler/texture)
GLuint fbo = 0; //FBO
GLuint renderedTexture = 0; //Render Texture for FBO
GLuint quad_vb; //buffer for vertices/coords for image

// OpenGL camera projection matrix (inside a sl::Transform)
sl::Transform camera_projection;

// OpenGL Viewport size
static const int wWnd = 1280;
static const int hWnd = 720;

// Spatial Mapping status
bool mapping_is_started = false;
// Utils
int grab_count;

//// Sample functions
void close();
void run();

void startMapping();
void stopMapping();

void keyPressedCallback(unsigned char c, int x, int y);
void generateQuadGL();
int initGL();
void drawGL();
void printGL(float x, float y, char *string);
void printHelp();

int main(int argc, char** argv) {
    // Init GLUT window
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA);
    glutInitWindowSize(wWnd, hWnd);
    glutCreateWindow("ZED Spatial Mapping");

	// Setup configuration parameters for the ZED    
    sl::InitParameters parameters;
	if (argc > 1) parameters.svo_input_filename = argv[1];
    parameters.depth_mode = sl::DEPTH_MODE_PERFORMANCE; // Use QUALITY depth mode to improve mapping results
    parameters.coordinate_units = sl::UNIT_METER;
    parameters.coordinate_system = sl::COORDINATE_SYSTEM_RIGHT_HANDED_Y_UP; // OpenGL coordinates system

	// Open the ZED
	sl::ERROR_CODE err = zed_.open(parameters);
	if (err != sl::ERROR_CODE::SUCCESS) {
		std::cout << sl::errorCode2str(err) << std::endl;
		zed_.close();
		return -1;
	}

	// Configure Spatial Mapping and filtering parameters
    spatial_mapping_params.range_meter.second = sl::SpatialMappingParameters::get(sl::SpatialMappingParameters::RANGE_FAR);
    spatial_mapping_params.resolution_meter = sl::SpatialMappingParameters::get(sl::SpatialMappingParameters::RESOLUTION_LOW);
    spatial_mapping_params.save_texture = false;
    filter_params.set(sl::MeshFilterParameters::FILTER_LOW);
    
    // Initialize OpenGL
    int res = initGL();
    if (res != 0) {
        std::cout << "Failed to initialize OpenGL" << std::endl;
        zed_.close();
        return -1;
    }

	printHelp();

    // Create callback function for keyboard event and main loop (display).
    // Then, start the glut main loop.
    glutKeyboardFunc(keyPressedCallback); //callback to handle key events
    glutDisplayFunc(run); //main loop callback
    glutCloseFunc(close); //close callback
    glutMainLoop();
    
    return 0;
}

void startMapping()
{
	// Create Mesh handler for sending the extracted mesh to OpenGL
	mesh_.clear();
	if (mesh_object) delete mesh_object;
	mesh_object = new MeshObject(sl::Translation(0, 0, 0), false);

	// Color of wireframe (soft blue)
	mesh_color.r = 0.35;
	mesh_color.g = 0.65;
	mesh_color.b = 0.85;

	// Enable tracking and spatial mapping.
	// Note: spatial mapping needs the motion tracking to operate. Don't forget to enable it as well.
	zed_.enableTracking();
	zed_.enableSpatialMapping(spatial_mapping_params);

	// Launch the first request of the mesh. Other requests will be done when current mesh has been retrieved
	zed_.requestMeshAsync();
	mapping_is_started = true;

	// Console information
	std::cout << "** Spatial Mapping is started ... **" << std::endl;
	return;
}

/**
* This function grabs the ZED data and draw the image with the projected mesh.
* This function is called everytime the display needs to be refreshed (50 or 60Hz)
**/
void run(){
	if (zed_.grab() == sl::SUCCESS){
		// Retrieve image in GPU and send it to OpenGL
		zed_.retrieveImage(left_image, sl::VIEW_LEFT, sl::MEM_GPU);

		// CUDA - OpenGL interop : copy the GPU buffer to a CUDA array mapped to the texture.
		cudaArray_t ArrIm;
		cudaGraphicsMapResources(1, &pcuImageRes, 0);
		cudaGraphicsSubResourceGetMappedArray(&ArrIm, pcuImageRes, 0, 0);
		cudaMemcpy2DToArray(ArrIm, 0, 0, left_image.getPtr<uchar>(sl::MEM_GPU), left_image.getStepBytes(sl::MEM_GPU), left_image.getWidth() * 4, left_image.getHeight(), cudaMemcpyDeviceToDevice);
		cudaGraphicsUnmapResources(1, &pcuImageRes, 0);

		// Get the pose data for future use (projection of the mesh in the current image)
        tracking_state = zed_.getPosition(pose_);

		// Spatial Mapping mesh request (only if Spatial Mapping is started)
		// Spatial Mapping is started/stopped when space bar is pressed (see keyPressedCallback())
		if (mapping_is_started) {
			// If mesh request status returns true, a new updated mesh is available. If not, then just do nothing : at next grab, we will check again.
			if (zed_.getMeshRequestStatusAsync()== sl::SUCCESS) {
				// Get the current mesh generated and send it to opengl
                if (zed_.retrieveMeshAsync(mesh_) == sl::SUCCESS)
                    mesh_object->updateMesh(mesh_);
				// Ask for a new update
				zed_.requestMeshAsync();
			}
		}
        
		////// OpenGL draw call
		// Always draw the mesh even if not updated. Since the camera position changes every frame, the mesh needs to be projected on the image, using the very last camera position 
		drawGL();
	}

    // Check if we are reading an SVO file, and close the window and stop the mapping if we reached the end
    if ( zed_.getSVOPosition() > 0 && zed_.getSVOPosition() == zed_.getSVONumberOfFrames()) {
        glutLeaveMainLoop();
        if (mapping_is_started)
            stopMapping();
    }

	// Get ready for next update
	glutPostRedisplay();
}

void stopMapping(){

	// --> stop the mesh request and extract the whole mesh to filter it and save it as an obj file
	mapping_is_started = false;

	std::cout << "** Stop Spatial Mapping ... **" << std::endl;

	// Extract the whole mesh and filter it
	zed_.extractWholeMesh(mesh_);
	std::cout << ">> Mesh has been extracted..." << std::endl;

	// Filter the extracted mesh
	mesh_.filter(filter_params);
	std::cout << ">> Mesh has been filtered..." << std::endl;

	// If textures have been saved during spatial mapping, apply them to the mesh
	if (spatial_mapping_params.save_texture) {
		mesh_.applyTexture();
		std::cout << ">> Mesh has been textured..." << std::endl;
	}

	//Save as an OBJ file
	bool t = mesh_.save("mesh_gen.obj");
	if (t) std::cout << ">> Mesh has been saved under \"mesh_gen.obj\" filename" << std::endl;
	else std::cout << ">> Failed to save the mesh under \"mesh_gen.obj\" filename" << std::endl;

	// Disable the spatial mapping module since we don't need it anymore
	zed_.disableSpatialMapping();

	return;
}

/**
*  This function close the sample (when a close event is generated)
**/
void close() {
	left_image.free();

	if (shader_mesh) delete shader_mesh; //GLSL Shader for mesh
	if (shader_image) delete shader_image; //GLSL Shader for image
	if (mesh_object) delete mesh_object;

	zed_.close();
}

/**
* Utils to generate quads for image texture
**/
void generateQuadGL() {
	// The fullscreen quad's FBO
	static const GLfloat g_quad_vertex_buffer_data[] = {
		-1.0f, -1.0f, 0.0f,
		1.0f, -1.0f, 0.0f,
		-1.0f, 1.0f, 0.0f,
		-1.0f, 1.0f, 0.0f,
		1.0f, -1.0f, 0.0f,
		1.0f, 1.0f, 0.0f};

	//Generate a buffer to handle vertices for the GLSL shader.
	glGenBuffers(1, &quad_vb);
	glBindBuffer(GL_ARRAY_BUFFER, quad_vb);
	glBufferData(GL_ARRAY_BUFFER, sizeof(g_quad_vertex_buffer_data), g_quad_vertex_buffer_data, GL_STATIC_DRAW);
}

/**
* This function initialize OpenGL window and objects
**/
int initGL() {
	//Init glew after window has been created
	glewInit();
	glClearColor(0.0, 0.0, 0.0, 0.0); // When screen cleared, use black.

    // Get Image resolution (depending on InitParameter.camera_resolution or svo resolution)
	int w = zed_.getResolution().width;
	int h = zed_.getResolution().height;

	//Create and Register OpenGL Texture for Image (RGBA -- 4channels)
	glEnable(GL_TEXTURE_2D);
	glGenTextures(1, &imageTex);
	glBindTexture(GL_TEXTURE_2D, imageTex);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_BGRA_EXT, GL_UNSIGNED_BYTE, NULL);
	glBindTexture(GL_TEXTURE_2D, 0);
	cudaError_t err1 = cudaGraphicsGLRegisterImage(&pcuImageRes, imageTex, GL_TEXTURE_2D, cudaGraphicsMapFlagsNone);
    if (err1 != cudaError::cudaSuccess) return -1;

	//Create GLSL Shaders Mesh and Image
	shader_mesh = new Shader((GLchar*)MESH_VERTEX_SHADER, (GLchar*)MESH_FRAGMENT_SHADER);
	shMVPMatrixLoc_ = glGetUniformLocation(shader_mesh->getProgramId(), "u_mvpMatrix");
	shColorLoc_ = glGetUniformLocation(shader_mesh->getProgramId(), "u_color");
	shader_image = new Shader((GLchar*)IMAGE_VERTEX_SHADER, (GLchar*)IMAGE_FRAGMENT_SHADER);
	texID = glGetUniformLocation(shader_image->getProgramId(), "texImage");

	/////////////// Create Frame Buffer for offline rendering //////////////////
	// Here we render the composition of the image and the projection of the mesh on top of it in a texture (using FBO - Frame Buffer Object)
	//
	glGenFramebuffers(1, &fbo);
	glBindFramebuffer(GL_FRAMEBUFFER, fbo);

	// Generate a render texture (which will contain the image and mesh in wireframe overlay)
	glGenTextures(1, &renderedTexture);
	glBindTexture(GL_TEXTURE_2D, renderedTexture);

	// Give an empty image to OpenGL ( the last "0" as pointer )
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, 0);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);

	// Set "renderedTexture" as our color attachment #0
	glFramebufferTexture(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, renderedTexture, 0);

	// Set the list of draw buffers.
	GLenum DrawBuffers[1] = { GL_COLOR_ATTACHMENT0 };
	glDrawBuffers(1, DrawBuffers);

	// Always check that our framebuffer is ok
	if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) {
		std::cout << "invalid FrameBuffer" << std::endl;
		return -1;
	}

	glBindFramebuffer(GL_FRAMEBUFFER, 0);

	///////////// Create Projection Matrix for OpenGL. We will use this matrix in combination with the Pose (on REFERENCE_FRAME_WORLD) to project the mesh on the 2D Image.
	sl::CameraParameters camLeft = zed_.getCameraInformation().calibration_parameters.left_cam;
	camera_projection(0, 0) = 1.0f / tanf(camLeft.h_fov * M_PI / 180.f * 0.5f);
	camera_projection(1, 1) = 1.0f / tanf(camLeft.v_fov * M_PI / 180.f * 0.5f);
	float znear = 0.001;
	float zfar = 100.;
	camera_projection(2, 2) = -(zfar + znear) / (zfar - znear);
	camera_projection(2, 3) = -(2.f * zfar * znear) / (zfar - znear);
	camera_projection(3, 2) = -1;
	camera_projection(0, 2) = (camLeft.image_size.width - 2. * camLeft.cx) / camLeft.image_size.width;
	camera_projection(1, 2) = (-1.f * camLeft.image_size.height + 2. * camLeft.cy) / camLeft.image_size.height;
	camera_projection(3, 3) = 0;

	////////////// Generate the Quad for showing the image in a full viewport
	generateQuadGL();

	return 0;
}

/**
* This function draws a text with OpenGL
**/
void printGL(float x, float y, char *string) {
	//set the position of the text in the window using the x and y coordinates
	glRasterPos2f(x, y);
	//get the length of the string to display
	int len = (int)strlen(string);
	//loop to display string
	for (int i = 0; i < len; i++) {
		glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, string[i]);
	}
}

/**
* OpenGL draw function
**/
void drawGL() {
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glEnable(GL_TEXTURE_2D);
	glActiveTexture(GL_TEXTURE0);

	glViewport(0, 0, wWnd, hWnd);

	///// Render Image and wireframe mesh into a texture using the FrameBuffer
	//Bind the framebuffer and specify the viewport (full screen)
	glBindFramebuffer(GL_FRAMEBUFFER, fbo);

	////////// Render the ZED view (Left) in the framebuffer
	glUseProgram(shader_image->getProgramId());
	glActiveTexture(GL_TEXTURE0);
	glBindTexture(GL_TEXTURE_2D, imageTex);
	glUniform1i(texID, 0);
	//invert y axis and color for this image (since its reverted from cuda array)
	glUniform1i(glGetUniformLocation(shader_image->getProgramId(), "revert"), 1);
	glUniform1i(glGetUniformLocation(shader_image->getProgramId(), "rgbflip"), 1);
	
	glEnableVertexAttribArray(0);
	glBindBuffer(GL_ARRAY_BUFFER, quad_vb);
	glVertexAttribPointer(
		0, // attribute 0
		3, // size
		GL_FLOAT, // type
		GL_FALSE, // normalized
		0, // stride
		(void*)0 // array buffer offset
	);

	glDrawArrays(GL_TRIANGLES, 0, 6); // 2*3 indices starting at 0 -> 2 triangles
	glDisableVertexAttribArray(0);
	glUseProgram(0);

    // if the Positional tracking is good, we can draw the mesh over the current image
	if (mesh_.triangles.size() && (tracking_state==sl::TRACKING_STATE_OK)) {
		glDisable(GL_TEXTURE_2D);
        // Send the projection and the Pose to the GLSL shader to make the projection of the 2D image.
		sl::Transform vpMatrix = sl::Transform::transpose(camera_projection * sl::Transform::inverse(pose_.pose_data));
		glUseProgram(shader_mesh->getProgramId());
		glUniformMatrix4fv(shMVPMatrixLoc_, 1, GL_FALSE, vpMatrix.m);
		glUniform3fv(shColorLoc_, 1, mesh_color.v);
        // Draw the mesh in GL_TRIANGLES with a polygon mode in line (wire)
		glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
		mesh_object->draw(GL_TRIANGLES);
		glUseProgram(0);
	}

	// Unbind the framebuffer since the texture is now updated.
	glBindFramebuffer(GL_FRAMEBUFFER, 0);

	// Render the texture to the screen
	//Set back the polygon mode
	glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);

	// Use the image shader to show it on the screen.
	glUseProgram(shader_image->getProgramId());
	glBindTexture(GL_TEXTURE_2D, renderedTexture);
	glUniform1i(texID, 0);
	glUniform1i(glGetUniformLocation(shader_image->getProgramId(), "revert"), 0);
	glUniform1i(glGetUniformLocation(shader_image->getProgramId(), "rgbflip"), 0);
	glEnableVertexAttribArray(0);
	glBindBuffer(GL_ARRAY_BUFFER, quad_vb);
	glVertexAttribPointer(
		0, // attribute 0
		3, // size
		GL_FLOAT, // type
		GL_FALSE, // normalized
		0, // stride
		(void*)0 // array buffer offset
	);
	// Draw the triangles
	glDrawArrays(GL_TRIANGLES, 0, 6);
	glDisableVertexAttribArray(0);
	glUseProgram(0);
	glDisable(GL_TEXTURE_2D);

	// show actions
	glColor4f(0.25f, 0.99f, 0.25f, 1.f);
	if (!mapping_is_started)
		printGL(-0.99f, 0.9f, "* Press Space Bar to activate Spatial Mapping.");
	else
		printGL(-0.99f, 0.9f, "* Press Space Bar to stop spatial mapping.");

	// show mapping state
    if ((tracking_state == sl::TRACKING_STATE_OK)) {
        sl::SPATIAL_MAPPING_STATE state = zed_.getSpatialMappingState();
        if (state == sl::SPATIAL_MAPPING_STATE_OK || state == sl::SPATIAL_MAPPING_STATE_INITIALIZING) {
            glColor4f(0.25f, 0.99f, 0.25f, 1.f);
            printGL(-0.99f, 0.83f, (char*)(std::string("** ") + sl::spatialMappingState2str(state)).c_str());
        } else if (state == sl::SPATIAL_MAPPING_STATE_NOT_ENABLED) {
            glColor4f(0.55f, 0.65f, 0.55f, 1.f);
            printGL(-0.99f, 0.83f, (char*)(std::string("** ") + sl::spatialMappingState2str(state)).c_str());
        } else {
            glColor4f(0.95f, 0.25f, 0.25f, 1.f);
            printGL(-0.99f, 0.83f, (char*)(std::string("** ") + sl::spatialMappingState2str(state)).c_str());
        }
    } else {
        if (mapping_is_started) {
            glColor4f(0.95f, 0.25f, 0.25f, 1.f);
            printGL(-0.99f, 0.83f, (char*)(std::string("** ") + sl::trackingState2str(tracking_state)).c_str());
        } else {
            glColor4f(0.55f, 0.65f, 0.55f, 1.f);
            printGL(-0.99f, 0.83f, (char*)(std::string("** ") + sl::spatialMappingState2str(sl::SPATIAL_MAPPING_STATE_NOT_ENABLED)).c_str());
        }
    }
	// Increment count and swap buffers
	grab_count++;
	glutSwapBuffers();
}

/**
* This function handles keyboard events (especially space bar to start the mapping)
**/
void keyPressedCallback(unsigned char c, int x, int y) {
	switch (c) {
	case 32: //space bar id	
	    if (!mapping_is_started) // User press the space bar and spatial mapping is not started 
		    startMapping();		
	    else // User press the space bar and spatial mapping is started 
		    stopMapping();	
	break;
	case 'q':
		std::cout << " 'q' has been pressed... Exit" << std::endl;
		glutLeaveMainLoop(); //this will call the close function	
	break;
	default:
        break;
	}
}

/**
* This function displays help in console
**/
void printHelp()
{
	std::cout << "*************************************************************" << std::endl;
	std::cout << "**      Press the Space Bar key to start and stop          **" << std::endl;
	std::cout << "*************************************************************" << std::endl;
}
